# This file describes the SQL grammar from the BNF rules defined in the SQL
# 2016 standard.
#
# Unfortunately, the standard is not open source, however, you can find the BNF
# at: https://jakewheat.github.io/sql-overview/sql-2016-foundation-grammar.html
#
# Many rules are missing, or only partially implemented.

<preparable statement> /* Stmt */ ::=
    <preparable SQL data statement>
  | <preparable SQL schema statement>
  | <preparable SQL transaction statement>
  | <preparable SQL session statement>

<SQL schema statement> /* Stmt */ ::=
    <SQL schema definition statement>
  | <SQL schema manipulation statement>

<SQL schema definition statement> /* Stmt */ ::=
    <schema definition>
  | <table definition>
  | <sequence generator definition>

<schema definition> /* Stmt */ ::=
    CREATE SCHEMA <schema name clause>   -> schema_definition

<schema name clause> /* Identifier */ ::=
    <schema name>

<schema name> /* Identifier */ ::=
    <catalog name> <period> <unqualified schema name>   -> schema_name_1
  | <unqualified schema name>

<unqualified schema name> /* Identifier */ ::=
    <identifier>   -> unqualified_schema_name

<SQL schema manipulation statement> /* Stmt */ ::=
    <drop schema statement>
  | <drop table statement>
  | <alter sequence generator statement>
  | <drop sequence generator statement>

<drop schema statement> /* Stmt */ ::=
    DROP SCHEMA <schema name> <drop behavior>   -> drop_schema_statement

<drop behavior> /* string */ ::=
    CASCADE
  | RESTRICT

<drop table statement> /* Stmt */ ::=
    DROP TABLE <table name>   -> drop_table_statement

<table name> /* Identifier */ ::=
    <local or schema qualified name>   -> table_name

<local or schema qualified name> /* IdentifierChain */ ::=
    <qualified identifier>
  | <local or schema qualifier> <period>
    <qualified identifier>                 -> local_or_schema_qualified_name2

<local or schema qualifier> /* Identifier */ ::=
    <schema name>

<qualified identifier> /* IdentifierChain */ ::=
    <identifier>

<identifier> /* IdentifierChain */ ::=
    <actual identifier>

<actual identifier> /* IdentifierChain */ ::=
    <regular identifier>

# <non-reserved word> is added on top of the original <regular identifier> to
# allow non-reserved words to be used as identifiers. As far as I can tell, only
# <reserved word>s are restricted. See "9075-2:2016 5.2 #26".
<regular identifier> /* IdentifierChain */ ::=
    <identifier body>
  | <non-reserved word>   -> string_identifier

<non-reserved word> /* string */ ::=
    A
  | ABSOLUTE
  | ACTION
  | ADA
  | ADD
  | ADMIN
  | AFTER
  | ALWAYS
  | ASC
  | ASSERTION
  | ASSIGNMENT
  | ATTRIBUTE
  | ATTRIBUTES
  | BEFORE
  | BERNOULLI
  | BREADTH
  | C
  | CASCADE
  | CATALOG
  | CATALOG_NAME
  | CHAIN
  | CHAINING
  | CHARACTER_SET_CATALOG
  | CHARACTER_SET_NAME
  | CHARACTER_SET_SCHEMA
  | CHARACTERISTICS
  | CHARACTERS
  | CLASS_ORIGIN
  | COBOL
  | COLLATION
  | COLLATION_CATALOG
  | COLLATION_NAME
  | COLLATION_SCHEMA
  | COLUMNS
  | COLUMN_NAME
  | COMMAND_FUNCTION
  | COMMAND_FUNCTION_CODE
  | COMMITTED
  | CONDITIONAL
  | CONDITION_NUMBER
  | CONNECTION
  | CONNECTION_NAME
  | CONSTRAINT_CATALOG
  | CONSTRAINT_NAME
  | CONSTRAINT_SCHEMA
  | CONSTRAINTS
  | CONSTRUCTOR
  | CONTINUE
  | CURSOR_NAME
  | DATA
  | DATETIME_INTERVAL_CODE
  | DATETIME_INTERVAL_PRECISION
  | DEFAULTS
  | DEFERRABLE
  | DEFERRED
  | DEFINED
  | DEFINER
  | DEGREE
  | DEPTH
  | DERIVED
  | DESC
  | DESCRIBE_CATALOG
  | DESCRIBE_NAME
  | DESCRIBE_PROCEDURE_SPECIFIC_CATALOG
  | DESCRIBE_PROCEDURE_SPECIFIC_NAME
  | DESCRIBE_PROCEDURE_SPECIFIC_SCHEMA
  | DESCRIBE_SCHEMA
  | DESCRIPTOR
  | DIAGNOSTICS
  | DISPATCH
  | DOMAIN
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | ENCODING
  | ENFORCED
  | ERROR
  | EXCLUDE
  | EXCLUDING
  | EXPRESSION
  | FINAL
  | FINISH
  | FINISH_CATALOG
  | FINISH_NAME
  | FINISH_PROCEDURE_SPECIFIC_CATALOG
  | FINISH_PROCEDURE_SPECIFIC_NAME
  | FINISH_PROCEDURE_SPECIFIC_SCHEMA
  | FINISH_SCHEMA
  | FIRST
  | FLAG
  | FOLLOWING
  | FORMAT
  | FORTRAN
  | FOUND
  | FULFILL
  | FULFILL_CATALOG
  | FULFILL_NAME
  | FULFILL_PROCEDURE_SPECIFIC_CATALOG
  | FULFILL_PROCEDURE_SPECIFIC_NAME
  | FULFILL_PROCEDURE_SPECIFIC_SCHEMA
  | FULFILL_SCHEMA
  | G
  | GENERAL
  | GENERATED
  | GO
  | GOTO
  | GRANTED
  | HAS_PASS_THROUGH_COLUMNS
  | HAS_PASS_THRU_COLS
  | HIERARCHY
  | IGNORE
  | IMMEDIATE
  | IMMEDIATELY
  | IMPLEMENTATION
  | INCLUDING
  | INCREMENT
  | INITIALLY
  | INPUT
  | INSTANCE
  | INSTANTIABLE
  | INSTEAD
  | INVOKER
  | ISOLATION
  | IS_PRUNABLE
  | JSON
  | K
  | KEEP
  | KEY
  | KEYS
  | KEY_MEMBER
  | KEY_TYPE
  | LAST
  | LENGTH
  | LEVEL
  | LOCATOR
  | M
  | MAP
  | MATCHED
  | MAXVALUE
  | MESSAGE_LENGTH
  | MESSAGE_OCTET_LENGTH
  | MESSAGE_TEXT
  | MINVALUE
  | MORE
  | MUMPS
  | NAME
  | NAMES
  | NESTED
  | NESTING
  | NEXT
  | NFC
  | NFD
  | NFKC
  | NFKD
  | NORMALIZED
  | NULLABLE
  | NULLS
  | NUMBER
  | OBJECT
  | OCTETS
  | OPTION
  | OPTIONS
  | ORDERING
  | ORDINALITY
  | OTHERS
  | OUTPUT
  | OVERFLOW
  | OVERRIDING
  | P
  | PAD
  | PARAMETER_MODE
  | PARAMETER_NAME
  | PARAMETER_ORDINAL_POSITION
  | PARAMETER_SPECIFIC_CATALOG
  | PARAMETER_SPECIFIC_NAME
  | PARAMETER_SPECIFIC_SCHEMA
  | PARTIAL
  | PASCAL
  | PASS
  | PASSING
  | PAST
  | PATH
  | PLACING
  | PLAN
  | PLI
  | PRECEDING
  | PRESERVE
  | PRIOR
  | PRIVATE
  | PRIVATE_PARAMETERS
  | PRIVATE_PARAMS_S
  | PRIVILEGES
  | PRUNE
  | PUBLIC
  | QUOTES
  | READ
  | RELATIVE
  | REPEATABLE
  | RESPECT
  | RESTART
  | RESTRICT
  | RETURNED_CARDINALITY
  | RETURNED_LENGTH
  | RETURNED_OCTET_LENGTH
  | RETURNED_SQLSTATE
  | RETURNING
  | RETURNS_ONLY_PASS_THROUGH
  | RET_ONLY_PASS_THRU
  | ROLE
  | ROUTINE
  | ROUTINE_CATALOG
  | ROUTINE_NAME
  | ROUTINE_SCHEMA
  | ROW_COUNT
  | SCALAR
  | SCALE
  | SCHEMA
  | SCHEMA_NAME
  | SCOPE_CATALOG
  | SCOPE_NAME
  | SCOPE_SCHEMA
  | SECTION
  | SECURITY
  | SELF
  | SEQUENCE
  | SERIALIZABLE
  | SERVER_NAME
  | SESSION
  | SETS
  | SIMPLE
  | SIZE
  | SOURCE
  | SPACE
  | SPECIFIC_NAME
  | START_CATALOG
  | START_NAME
  | START_PROCEDURE_SPECIFIC_CATALOG
  | START_PROCEDURE_SPECIFIC_NAME
  | START_PROCEDURE_SPECIFIC_SCHEMA
  | START_SCHEMA
  | STATE
  | STATEMENT
  | STRING
  | STRUCTURE
  | STYLE
  | SUBCLASS_ORIGIN
  | T
  | TABLE_NAME
  | TABLE_SEMANTICS
  | TEMPORARY
  | THROUGH
  | TIES
  | TOP_LEVEL_COUNT
  | TRANSACTION
  | TRANSACTION_ACTIVE
  | TRANSACTIONS_COMMITTED
  | TRANSACTIONS_ROLLED_BACK
  | TRANSFORM
  | TRANSFORMS
  | TRIGGER_CATALOG
  | TRIGGER_NAME
  | TRIGGER_SCHEMA
  | TYPE
  | UNBOUNDED
  | UNCOMMITTED
  | UNCONDITIONAL
  | UNDER
  | UNNAMED
  | USAGE
  | USER_DEFINED_TYPE_CATALOG
  | USER_DEFINED_TYPE_CODE
  | USER_DEFINED_TYPE_NAME
  | USER_DEFINED_TYPE_SCHEMA
  | UTF16
  | UTF32
  | UTF8
  | VIEW
  | WORK
  | WRAPPER
  | WRITE
  | ZONE

<identifier body> /* IdentifierChain */ ::=
    <identifier start>

<identifier start> /* IdentifierChain */ ::=
    ^identifier

<table definition> /* CreateTableStmt */ ::=
    CREATE TABLE <table name> <table contents source>   -> table_definition

<table contents source> /* []TableElement */ ::=
    <table element list>

<table element list> /* []TableElement */ ::=
    <left paren>
    <table elements>
    <right paren>      -> table_element_list

<table elements> /* []TableElement */ ::=
    <table element>                            -> table_elements1
  | <table elements> <comma> <table element>   -> table_elements2

<table element> /* TableElement */ ::=
    <column definition>
  | <table constraint definition>

<column definition> /* TableElement */ ::=
    <column name> <data type or domain name>   -> column_definition1
  | <column name> <data type or domain name>
    <column constraint definition>             -> column_definition2

<column name> /* Identifier */ ::=
    <identifier>   -> column_name

<data type or domain name> /* Type */ ::=
    <data type>

<data type> /* Type */ ::=
    <predefined type>

<predefined type> /* Type */ ::=
    <character string type>
  | <numeric type>
  | <boolean type>
  | <datetime type>

<character string type> /* Type */ ::=
    CHARACTER                                                         -> character
  | CHARACTER <left paren> <character length> <right paren>           -> character_n
  | CHAR                                                              -> character
  | CHAR <left paren> <character length> <right paren>                -> character_n
  | CHARACTER VARYING <left paren> <character length> <right paren>   -> varchar
  | CHAR VARYING <left paren> <character length> <right paren>        -> varchar
  | VARCHAR <left paren> <character length> <right paren>             -> varchar

<left paren> ::= "("

<right paren> ::= ")"

<character length> /* string */ ::=
    <length>

<length> /* string */ ::=
    <unsigned integer>

<unsigned integer> /* string */ ::=
    ^integer

<comma> ::= ","

<numeric type> /* Type */ ::=
    <exact numeric type>
  | <approximate numeric type>

<exact numeric type> /* Type */ ::=
    SMALLINT   -> smallint
  | INTEGER    -> integer
  | INT        -> integer
  | BIGINT     -> bigint

<approximate numeric type> /* Type */ ::=
    FLOAT                                          -> float
  | FLOAT <left paren> <precision> <right paren>   -> float_n
  | REAL                                           -> real
  | DOUBLE PRECISION                               -> double_precision

<precision> /* string */ ::=
    <unsigned integer>

<boolean type> /* Type */ ::=
    BOOLEAN   -> boolean_type

<null specification> /* Expr */ ::=
    NULL   -> null

<implicitly typed value specification> /* Expr */ ::=
    <null specification>

<contextually typed value specification> /* Expr */ ::=
    <implicitly typed value specification>

<contextually typed row value constructor> /* []Expr */ ::=
    <common value expression>                        -> expr_to_list
  | <boolean value expression>                       -> expr_to_list
  | <contextually typed value specification>         -> expr_to_list
  | <left paren> <contextually typed value specification>
    <right paren>                                    -> expr_to_list
  | <left paren>
    <contextually typed row value constructor element> <comma>
    <contextually typed row value constructor element list>
    <right paren>                                    -> append_exprs2

<contextually typed row value constructor element> /* Expr */ ::=
    <value expression>
  | <contextually typed value specification>

<contextually typed row value constructor element list> /* []Expr */ ::=
    <contextually typed row value constructor element>        -> expr_to_list
  | <contextually typed row value constructor element list>
    <comma>
    <contextually typed row value constructor element>        -> append_exprs1

<column constraint> /* bool */ ::=
    NOT NULL   -> yes

<column constraint definition> /* bool */ ::=
    <column constraint>

<delete statement: searched> /* Stmt */ ::=
    DELETE FROM <target table>   -> delete_statement
  | DELETE FROM <target table>
    WHERE <search condition>     -> delete_statement_where

<target table> /* Identifier */ ::=
    <table name>

<preparable SQL data statement> /* Stmt */ ::=
    <delete statement: searched>
  | <insert statement>
  | <dynamic select statement>
  | <update statement: searched>

<preparable SQL schema statement> /* Stmt */ ::=
    <SQL schema statement>

<exact numeric literal> /* Value */ ::=
    <unsigned integer>                               -> int_value
  | <unsigned integer> <period>                      -> int_value
  | <unsigned integer> <period> <unsigned integer>   -> exact_numeric_literal1
  | <period> <unsigned integer>                      -> exact_numeric_literal2

<unsigned numeric literal> /* Value */ ::=
    <exact numeric literal>

<unsigned literal> /* Value */ ::=
    <unsigned numeric literal>
  | <general literal>

<unsigned value specification> /* Expr */ ::=
    <unsigned literal>              -> value_to_expr
  | <general value specification>

<nonparenthesized value expression primary> /* Expr */ ::=
    <unsigned value specification>
  | <column reference>               -> identifier_to_expr
  | <set function specification>
  | <routine invocation>
  | <case expression>
  | <cast specification>
  | <next value expression>

<value expression primary> /* Expr */ ::=
    <parenthesized value expression>
  | <nonparenthesized value expression primary>

<numeric primary> /* Expr */ ::=
    <value expression primary>
  | <numeric value function>

<factor> /* Expr */ ::=
    <numeric primary>
  | <sign> <numeric primary>   -> sign_expr

<sign> /* string */ ::=
    <plus sign>
  | <minus sign>

<plus sign> /* string */ ::=
  "+"

<minus sign> /* string */ ::=
  "-"

<term> /* Expr */ ::=
    <factor>
  | <term> <asterisk> <factor>   -> binary_expr
  | <term> <solidus> <factor>    -> binary_expr

<asterisk> /* string */ ::=
  "*"

<solidus> /* string */ ::=
  "/"

<numeric value expression> /* Expr */ ::=
    <term>
  | <numeric value expression> <plus sign> <term>    -> binary_expr
  | <numeric value expression> <minus sign> <term>   -> binary_expr

<common value expression> /* Expr */ ::=
    <numeric value expression>
  | <string value expression>
  | <datetime value expression>

<datetime value expression> /* Expr */ ::=
    <datetime term>

<datetime term> /* Expr */ ::=
    <datetime factor>

<datetime factor> /* Expr */ ::=
    <datetime primary>

<datetime primary> /* Expr */ ::=
    <value expression primary>
  | <datetime value function>

<datetime value function> /* Expr */ ::=
    <current date value function>
  | <current time value function>
  | <current timestamp value function>
  | <current local time value function>
  | <current local timestamp value function>

<current date value function> /* Expr */ ::=
    CURRENT_DATE   -> current_date

<current time value function> /* Expr */ ::=
    CURRENT_TIME                                               -> current_time1
  | CURRENT_TIME <left paren> <time precision> <right paren>   -> current_time2

<current timestamp value function> /* Expr */ ::=
    CURRENT_TIMESTAMP                                  -> current_timestamp1
  | CURRENT_TIMESTAMP
    <left paren> <timestamp precision> <right paren>   -> current_timestamp2

<current local time value function> /* Expr */ ::=
    LOCALTIME                                               -> localtime1
  | LOCALTIME <left paren> <time precision> <right paren>   -> localtime2

<current local timestamp value function> /* Expr */ ::=
    LOCALTIMESTAMP                                     -> localtimestamp1
  | LOCALTIMESTAMP
    <left paren> <timestamp precision> <right paren>   -> localtimestamp2

<value expression> /* Expr */ ::=
    <common value expression>
  | <boolean value expression>

<search condition> /* Expr */ ::=
    <boolean value expression>

<boolean value expression> /* Expr */ ::=
    <boolean term>
  | <boolean value expression> OR <boolean term>   -> or

<boolean term> /* Expr */ ::=
    <boolean factor>
  | <boolean term> AND <boolean factor>   -> and

<boolean factor> /* Expr */ ::=
    <boolean test>
  | NOT <boolean test>   -> not

<boolean test> /* Expr */ ::=
    <boolean primary>
  | <boolean primary> IS <truth value>       -> boolean_test1
  | <boolean primary> IS NOT <truth value>   -> boolean_test2

<boolean primary> /* Expr */ ::=
    <predicate>
  | <boolean predicand>

<predicate> /* Expr */ ::=
    <comparison predicate>
  | <between predicate>
  | <like predicate>
  | <similar predicate>
  | <null predicate>

<comparison predicate> /* Expr */ ::=
    <row value predicand> <comparison predicate part 2>   -> comparison

<row value predicand> /* Expr */ ::=
  <row value constructor predicand>

<row value constructor predicand> /* Expr */ ::=
    <common value expression>
  | <boolean predicand>

<comparison predicate part 2> /* ComparisonPredicatePart2 */ ::=
    <comp op> <row value predicand>   -> comparison_part

<comp op> /* string */ ::=
    <equals operator>
  | <not equals operator>
  | <less than operator>
  | <greater than operator>
  | <less than or equals operator>
  | <greater than or equals operator>

<equals operator> ::= "="

<not equals operator> ::= "<>"

<less than operator> ::= "<"

<greater than operator> ::= ">"

<less than or equals operator> ::= "<="

<greater than or equals operator> ::= ">="

<period> ::= "."

<column reference> /* Identifier */ ::=
    <basic identifier chain>   -> column_reference

<basic identifier chain> /* IdentifierChain */ ::=
    <identifier chain>

<identifier chain> /* IdentifierChain */ ::=
    <identifier>
  | <identifier> <period> <identifier>   -> identifier_chain1

<insert statement> /* Stmt */ ::=
    INSERT INTO
    <insertion target>
    <insert columns and source>   -> insert_statement

<insertion target> /* Identifier */ ::=
    <table name>

<insert columns and source> /* InsertStmt */ ::=
  <from constructor>

<from constructor> /* InsertStmt */ ::=
    <left paren> <insert column list> <right paren>
    <contextually typed table value constructor>   -> from_constructor

<insert column list> /* []Identifier */ ::=
    <column name list>

<column name list> /* []Identifier */ ::=
    <column name>                              -> column_name_list1
  | <column name list> <comma> <column name>   -> column_name_list2

<contextually typed table value constructor> /* []Expr */ ::=
    VALUES <contextually typed row value expression list>   -> exprs

<contextually typed row value expression list> /* []Expr */ ::=
    <contextually typed row value expression>
  | <contextually typed row value expression list> <comma>
    <contextually typed row value expression>                -> merge_expr_lists

<contextually typed row value expression> /* []Expr */ ::=
  <contextually typed row value constructor>

<parenthesized value expression> /* Expr */ ::=
    <left paren> <value expression> <right paren>   -> expr

<character string literal> /* Value */ ::=
    ^string

<general literal> /* Value */ ::=
    <character string literal>
  | <datetime literal>
  | <boolean literal>

<datetime literal> /* Value */ ::=
    <date literal>
  | <time literal>
  | <timestamp literal>

<date literal> /* Value */ ::=
    DATE <date string>   -> date_literal

<date string> /* Value */ ::=
    ^string

<time literal> /* Value */ ::=
    TIME <time string>   -> time_literal

<time string> /* Value */ ::=
    ^string

<timestamp literal> /* Value */ ::=
    TIMESTAMP <timestamp string>   -> timestamp_literal

<timestamp string> /* Value */ ::=
    ^string

<boolean literal> /* Value */ ::=
    TRUE      -> true
  | FALSE     -> false
  | UNKNOWN   -> unknown

<update statement: searched> /* Stmt */ ::=
    UPDATE <target table>
    SET <set clause list>      -> update_statement
  | UPDATE <target table>
    SET <set clause list>
    WHERE <search condition>   -> update_statement_where

<set clause list> /* map[string]Expr */ ::=
    <set clause>
  | <set clause list> <comma> <set clause>   -> set_clause_append

<set clause> /* map[string]Expr */ ::=
  <set target> <equals operator> <update source>   -> set_clause

<set target> /* Identifier */ ::=
    <update target>

<update target> /* Identifier */ ::=
    <object column>

<object column> /* Identifier */ ::=
    <column name>

<update source> /* Expr */ ::=
    <value expression>
  | <contextually typed value specification>

<dynamic select statement> /* Stmt */ ::=
    <cursor specification>

<cursor specification> /* Stmt */ ::=
    <query expression>   -> cursor_specification

<query expression> /* QueryExpression */ ::=
    <query expression body>                     -> query_expression
  | <query expression body> <order by clause>   -> query_expression_order
  | <query expression body>
    <result offset clause>                      -> query_expression_offset
  | <query expression body> <order by clause>
    <result offset clause>                      -> query_expression_order_offset
  | <query expression body>
    <fetch first clause>                        -> query_expression_fetch
  | <query expression body> <order by clause>
    <fetch first clause>                        -> query_expression_order_fetch
  | <query expression body> <order by clause>
    <result offset clause>
    <fetch first clause>                        -> query_expression_order_offset_fetch
  | <query expression body>
    <result offset clause>
    <fetch first clause>                        -> query_expression_offset_fetch

<query expression body> /* SimpleTable */ ::=
    <query term>

<query term> /* SimpleTable */ ::=
    <query primary>

<query primary> /* SimpleTable */ ::=
    <simple table>

<simple table> /* SimpleTable */ ::=
    <query specification>
  | <table value constructor>

<query specification> /* SimpleTable */ ::=
    SELECT
    <select list>
    <table expression>   -> query_specification

<select list> /* SelectList */ ::=
    <asterisk>                               -> asterisk
  | <select sublist>
  | <select list> <comma> <select sublist>   -> select_list2

<select sublist> /* SelectList */ ::=
    <derived column>       -> select_sublist1
  | <qualified asterisk>   -> select_sublist2

<qualified asterisk> /* QualifiedAsteriskExpr */ ::=
    <asterisked identifier chain> <period> <asterisk>   -> qualified_asterisk

<asterisked identifier chain> /* IdentifierChain */ ::=
    <asterisked identifier>

<asterisked identifier> /* IdentifierChain */ ::=
    <identifier>

<derived column> /* DerivedColumn */ ::=
    <value expression>               -> derived_column
  | <value expression> <as clause>   -> derived_column_as

<table expression> /* TableExpression */ ::=
    <from clause>                                    -> table_expression
  | <from clause> <where clause>                     -> table_expression_where
  | <from clause> <group by clause>                  -> table_expression_group
  | <from clause> <where clause> <group by clause>   -> table_expression_where_group

<from clause> /* TableReference */ ::=
    FROM <table reference list>   -> from_clause

<table reference list> /* TableReference */ ::=
    <table reference>

<table reference> /* TableReference */ ::=
    <table factor>   -> table_factor
  | <joined table>   -> joined_table

<joined table> /* QualifiedJoin */ ::=
    <qualified join>

<qualified join> /* QualifiedJoin */ ::=
    <table reference>
    JOIN <table reference> <join specification>   -> qualified_join1
  | <table reference> <join type>
    JOIN <table reference> <join specification>   -> qualified_join2

<join specification> /* Expr */ ::=
    <join condition>

<join condition> /* Expr */ ::=
    ON <search condition>   -> expr

<table factor> /* TablePrimary */ ::=
    <table primary>

<table primary> /* TablePrimary */ ::=
    <table or query name>                          -> table_primary_identifier
  | <derived table>                                -> table_primary_derived1
  | <derived table> <correlation or recognition>   -> table_primary_derived2

<table or query name> /* Identifier */ ::=
    <table name>

<as clause> /* Identifier */ ::=
    AS <column name>   -> identifier
  | <column name>

<where clause> /* Expr */ ::=
    WHERE <search condition>   -> expr

<null predicate part 2> /* bool */ ::=
    IS NULL       -> yes
  | IS NOT NULL   -> no

<null predicate> /* Expr */ ::=
    <row value predicand> <null predicate part 2>   -> null_predicate

<absolute value expression> /* Expr */ ::=
    ABS <left paren> <numeric value expression> <right paren>   -> abs

<numeric value function> /* Expr */ ::=
    <position expression>
  | <length expression>
  | <absolute value expression>
  | <modulus expression>
  | <trigonometric function>
  | <common logarithm>
  | <natural logarithm>
  | <exponential function>
  | <power function>
  | <square root>
  | <floor function>
  | <ceiling function>

<modulus expression> /* Expr */ ::=
    MOD <left paren> <numeric value expression dividend> <comma> 
    <numeric value expression divisor> <right paren>               -> mod

<numeric value expression dividend> /* Expr */ ::=
    <numeric value expression>

<numeric value expression divisor> /* Expr */ ::=
    <numeric value expression>

<trigonometric function> /* Expr */ ::=
    <trigonometric function name>
    <left paren> <numeric value expression> 
    <right paren>                             -> trig_func

<trigonometric function name> /* string */ ::=
    SIN
  | COS
  | TAN
  | SINH
  | COSH
  | TANH
  | ASIN
  | ACOS
  | ATAN

<common logarithm> /* Expr */ ::=
    LOG10 <left paren> <numeric value expression> <right paren>   -> log10

<natural logarithm> /* Expr */ ::=
    LN <left paren> <numeric value expression> <right paren>   -> ln

<exponential function> /* Expr */ ::=
    EXP <left paren> <numeric value expression> <right paren>   -> exp

<power function> /* Expr */ ::=
    POWER <left paren> <numeric value expression base> <comma> 
    <numeric value expression exponent> <right paren>            -> power

<numeric value expression base> /* Expr */ ::=
    <numeric value expression>

<numeric value expression exponent> /* Expr */ ::=
    <numeric value expression>

<square root> /* Expr */ ::=
    SQRT <left paren> <numeric value expression> <right paren>   -> sqrt

<floor function> /* Expr */ ::=
    FLOOR <left paren> <numeric value expression> <right paren>   -> floor

<ceiling function> /* Expr */ ::=
    CEIL <left paren> <numeric value expression> <right paren>      -> ceiling
  | CEILING <left paren> <numeric value expression> <right paren>   -> ceiling

<concatenation> /* Expr */ ::=
    <character value expression>
    <concatenation operator>
    <character factor>             -> concatenation

<character value expression> /* Expr */ ::=
    <concatenation>
  | <character factor>

<concatenation operator> ::= "||"

<character factor> /* Expr */ ::=
    <character primary>

<character primary> /* Expr */ ::=
    <value expression primary>
  | <string value function>

<string value expression> /* Expr */ ::=
    <character value expression>

<boolean predicand> /* Expr */ ::=
    <parenthesized boolean value expression>
  | <nonparenthesized value expression primary>

<parenthesized boolean value expression> /* Expr */ ::=
    <left paren> <boolean value expression> <right paren>   -> expr

<result offset clause> /* Expr */ ::=
    OFFSET <offset row count> <row or rows>   -> expr

<offset row count> /* Expr */ ::=
    <simple value specification>

<simple value specification> /* Expr */ ::=
    <literal>
  | <host parameter name>

<literal> /* Expr */ ::=
    <signed numeric literal>
  | <general literal>          -> value_to_expr

<signed numeric literal> /* Expr */ ::=
    <unsigned numeric literal>          -> value_to_expr
  | <sign> <unsigned numeric literal>   -> sign_expr

<fetch first clause> /* Expr */ ::=
    FETCH FIRST
    <fetch first quantity>
    <row or rows>
    ONLY                     -> fetch_first_clause

<row or rows> ::=
    ROW
  | ROWS

<fetch first quantity> /* Expr */ ::=
    <fetch first row count>

<fetch first row count> /* Expr */ ::=
    <simple value specification>

<routine invocation> /* Expr */ ::=
    <routine name> <SQL argument list>   -> routine_invocation

<routine name> /* Identifier */ ::=
    <qualified identifier>   -> routine_name

<SQL argument list> /* []Expr */ ::=
    <left paren> <right paren>                  -> empty_exprs
  | <left paren> <SQL argument> <right paren>   -> expr_to_list
  | <left paren> <SQL argument list> <comma>
    <SQL argument> <right paren>                -> append_exprs1

<SQL argument> /* Expr */ ::=
    <value expression>

<general value specification> /* Expr */ ::=
    <host parameter specification>
  | CURRENT_CATALOG                  -> current_catalog
  | CURRENT_SCHEMA                   -> current_schema

<host parameter specification> /* Expr */ ::=
    <host parameter name>

<host parameter name> /* Expr */ ::=
    <colon> <identifier>   -> host_parameter_name

<colon> ::=
  ":"

<unique specification> ::=
  PRIMARY KEY   -> ignore

<unique constraint definition> /* TableElement */ ::=
  <unique specification> <left paren>
  <unique column list> <right paren>    -> unique_constraint_definition

<unique column list> /* []Identifier */ ::=
  <column name list>

<table constraint> /* TableElement */ ::=
  <unique constraint definition>

<table constraint definition> /* TableElement */ ::=
  <table constraint>

<position expression> /* Expr */ ::=
    <character position expression>

<character position expression> /* Expr */ ::=
    POSITION <left paren> <character value expression 1> IN 
    <character value expression 2> <right paren>              -> position

<character value expression 1> /* Expr */ ::=
    <character value expression>

<character value expression 2> /* Expr */ ::=
    <character value expression>

<length expression> /* Expr */ ::=
    <char length expression>
  | <octet length expression>

<char length expression> /* Expr */ ::=
    CHAR_LENGTH
    <left paren> <character value expression> <right paren>   -> char_length
  | CHARACTER_LENGTH
    <left paren> <character value expression> <right paren>   -> char_length

<octet length expression> /* Expr */ ::=
    OCTET_LENGTH
    <left paren> <string value expression> <right paren>   -> octet_length

<start transaction statement> /* Stmt */ ::=
  START TRANSACTION   -> start_transaction

<commit statement> /* Stmt */ ::=
    COMMIT        -> commit
  | COMMIT WORK   -> commit

<rollback statement> /* Stmt */ ::=
    ROLLBACK        -> rollback
  | ROLLBACK WORK   -> rollback

<SQL transaction statement> /* Stmt */ ::=
    <start transaction statement>
  | <commit statement>
  | <rollback statement>

<preparable SQL transaction statement> /* Stmt */ ::=
  <SQL transaction statement>

<between predicate> /* Expr */ ::=
    <row value predicand> <between predicate part 2>   -> between

<between predicate part 2> /* BetweenExpr */ ::=
    <between predicate part 1>
    <row value predicand> AND <row value predicand>   -> between1
  | <between predicate part 1> <is symmetric>
    <row value predicand> AND <row value predicand>   -> between2

<between predicate part 1> /* bool */ ::=
    BETWEEN       -> yes
  | NOT BETWEEN   -> no

<is symmetric> /* bool */ ::=
    SYMMETRIC    -> yes
  | ASYMMETRIC   -> no

<table value constructor> /* SimpleTable */ ::=
    VALUES <row value expression list>   -> table_value_constructor

<row value expression list> /* []Expr */ ::=
    <table row value expression>           -> expr_to_list
  | <row value expression list>
    <comma> <table row value expression>   -> append_exprs1

<table row value expression> /* Expr */ ::=
    <row value constructor>

<row value constructor> /* Expr */ ::=
    <common value expression>
  | <boolean value expression>
  | <explicit row value constructor>

<derived table> /* TablePrimary */ ::=
    <table subquery>

<table subquery> /* TablePrimary */ ::=
    <subquery>

<subquery> /* TablePrimaryBody */ ::=
    <left paren> <query expression> <right paren>   -> subquery

<correlation or recognition> /* Correlation */ ::=
    <correlation name>                    -> correlation1
  | AS <correlation name>                 -> correlation1
  | <correlation name>
    <parenthesized derived column list>   -> correlation2
  | AS <correlation name>
    <parenthesized derived column list>   -> correlation2

<correlation name> /* Identifier */ ::=
    <identifier>   -> correlation_name

<parenthesized derived column list> /* []Identifier */ ::=
    <left paren> <derived column list>
    <right paren>                        -> parenthesized_derived_column_list

<derived column list> /* []Identifier */ ::=
    <column name list>

<explicit row value constructor> /* Expr */ ::=
    ROW <left paren> <row value constructor element list>
    <right paren>                                           -> row_constructor1
  | <row subquery>                                          -> row_constructor2

<row value constructor element list> /* []Expr */ ::=
    <row value constructor element>                -> expr_to_list
  | <row value constructor element list> <comma>
    <row value constructor element>                -> append_exprs1

<row value constructor element> /* Expr */ ::=
    <value expression>

<row subquery> /* QueryExpression */ ::=
    <subquery>

<character like predicate part 2> /* LikeExpr */ ::=
    LIKE <character pattern>       -> like
  | NOT LIKE <character pattern>   -> not_like

<character pattern> /* Expr */ ::=
    <character value expression>

<character like predicate> /* Expr */ ::=
    <row value predicand> <character like predicate part 2>   -> like_pred

<like predicate> /* Expr */ ::=
    <character like predicate>

<similar predicate part 2> /* SimilarExpr */ ::=
    SIMILAR TO <similar pattern>       -> similar
  | NOT SIMILAR TO <similar pattern>   -> not_similar

<similar pattern> /* Expr */ ::=
    <character value expression>

<similar predicate> /* Expr */ ::=
    <row value predicand> <similar predicate part 2>   -> similar_pred

<order by clause> /* []SortSpecification */ ::=
    ORDER BY <sort specification list>   -> order_by

<sort specification list> /* []SortSpecification */ ::=
    <sort specification>                                     -> sort_list1
  | <sort specification list> <comma> <sort specification>   -> sort_list2

<sort specification> /* SortSpecification */ ::=
    <sort key>                            -> sort1
  | <sort key> <ordering specification>   -> sort2

<sort key> /* Expr */ ::=
    <value expression>

<ordering specification> /* bool */ ::=
    ASC    -> yes
  | DESC   -> no

<character value function> /* Expr */ ::=
    <character substring function>
  | <fold>
  | <trim function>

<trim function> /* Expr */ ::=
  TRIM <left paren> <trim operands> <right paren>   -> trim

<trim operands> /* Expr */ ::=
    <trim source>                                              -> trim1
  | FROM <trim source>                                         -> trim1
  | <trim specification> FROM <trim source>                    -> trim2
  | <trim character> FROM <trim source>                        -> trim3
  | <trim specification> <trim character> FROM <trim source>   -> trim4

<trim source> /* Expr */ ::=
    <character value expression>

<trim specification> /* string */ ::=
    LEADING
  | TRAILING
  | BOTH

<trim character> /* Expr */ ::=
    <character value expression>

<fold> /* Expr */ ::=
    UPPER <left paren> <character value expression> <right paren>   -> upper
  | LOWER <left paren> <character value expression> <right paren>   -> lower

<string value function> /* Expr */ ::=
    <character value function>

<group by clause> /* []Expr */ ::=
    GROUP BY <grouping element list>   -> exprs

<grouping element list> /* []Expr */ ::=
    <grouping element>                                   -> expr_to_list
  | <grouping element list> <comma> <grouping element>   -> append_exprs1

<grouping element> /* Expr */ ::=
    <ordinary grouping set>

<ordinary grouping set> /* Expr */ ::=
    <grouping column reference>

<grouping column reference> /* Expr */ ::=
    <column reference>   -> identifier_to_expr

<aggregate function> /* Expr */ ::=
    COUNT <left paren> <asterisk> <right paren>   -> count_all
  | <general set function>

<set function specification> /* Expr */ ::=
    <aggregate function>

<general set function> /* Expr */ ::=
    <set function type> <left paren>
    <value expression> <right paren>   -> general_set_function

<set function type> /* string */ ::=
    <computational operation>

<computational operation> /* string */ ::=
    AVG
  | MAX
  | MIN
  | SUM
  | COUNT

<outer join type> /* string */ ::=
    LEFT
  | RIGHT

<join type> /* string */ ::=
    INNER
  | <outer join type>
  | <outer join type> OUTER   -> string

<datetime type> /* Type */ ::=
    DATE                                               -> date_type
  | TIME                                               -> time_type
  | TIME <left paren> <time precision> <right paren>   -> time_prec_type
  | TIME <with or without time zone>                   -> time_tz_type
  | TIME <left paren> <time precision> <right paren>
    <with or without time zone>                        -> time_prec_tz_type
  | TIMESTAMP                                          -> timestamp_type
  | TIMESTAMP
    <left paren> <timestamp precision> <right paren>   -> timestamp_prec_type
  | TIMESTAMP <with or without time zone>              -> timestamp_tz_type
  | TIMESTAMP
    <left paren> <timestamp precision> <right paren>
    <with or without time zone>                        -> timestamp_prec_tz_type

<time precision> /* string */ ::=
    <time fractional seconds precision>

<time fractional seconds precision> /* string */ ::=
    <unsigned integer>

<with or without time zone> /* bool */ ::=
    WITH TIME ZONE      -> yes
  | WITHOUT TIME ZONE   -> no

<timestamp precision> /* string */ ::=
    <time fractional seconds precision>

<time fractional seconds precision> /* string */ ::=
    <unsigned integer>

<character substring function> /* Expr */ ::=
    SUBSTRING <left paren> <character value expression>
    FROM <start position> <right paren>                   -> substring1
  | SUBSTRING <left paren> <character value expression>
    FROM <start position> 
    FOR <string length> <right paren>                     -> substring2
  | SUBSTRING <left paren> <character value expression>
    FROM <start position> 
    USING <char length units> <right paren>               -> substring3
  | SUBSTRING <left paren> <character value expression>
    FROM <start position> 
    FOR <string length>
    USING <char length units> <right paren>               -> substring4

<start position> /* Expr */ ::=
    <numeric value expression>

<string length> /* Expr */ ::=
    <numeric value expression>

<char length units> /* string */ ::=
    CHARACTERS
  | OCTETS

<truth value> /* Value */ ::=
    TRUE      -> true
  | FALSE     -> false
  | UNKNOWN   -> unknown

<cast specification> /* Expr */ ::=
    CAST <left paren> <cast operand> AS <cast target> <right paren>   -> cast

<cast operand> /* Expr */ ::=
    <value expression>
  | <implicitly typed value specification>

<cast target> /* Type */ ::=
    <data type>

<value expression list> /* []Expr */ ::=
    <value expression>                                   -> expr_to_list
  | <value expression list> <comma> <value expression>   -> append_exprs1

<case abbreviation> /* Expr */ ::=
    NULLIF <left paren> <value expression>
    <comma> <value expression> <right paren>                      -> nullif
  | COALESCE <left paren> <value expression list> <right paren>   -> coalesce

<case expression> /* Expr */ ::=
    <case abbreviation>

<sequence generator definition> /* Stmt */ ::=
    CREATE SEQUENCE
    <sequence generator name>                   -> sequence_generator_definition_1
  | CREATE SEQUENCE <sequence generator name>
    <sequence generator options>                -> sequence_generator_definition_2

<sequence generator name> /* Identifier */ ::=
    <schema qualified name>   -> sequence_generator_name

<schema qualified name> /* IdentifierChain */ ::=
    <qualified identifier>
  | <schema name> <period> <qualified identifier>   -> schema_qualified_name_2

<sequence generator options> /* []SequenceGeneratorOption */ ::=
    <sequence generator option>
  | <sequence generator options> <sequence generator option>

<sequence generator option> /* []SequenceGeneratorOption */ ::=
    <common sequence generator options>

<common sequence generator options> /* []SequenceGeneratorOption */ ::=
    <common sequence generator option>    -> sequence_generator_options_1
  | <common sequence generator options>
    <common sequence generator option>    -> sequence_generator_options_2

<common sequence generator option> /* SequenceGeneratorOption */ ::=
    <sequence generator start with option>   -> common_sequence_generator_option_1
  | <basic sequence generator option>

<sequence generator start with option> /* SequenceGeneratorStartWithOption */ ::=
    START WITH
    <sequence generator start value>   -> sequence_generator_start_with_option

<sequence generator start value> /* Expr */ ::=
    <signed numeric literal>

<basic sequence generator option> /* SequenceGeneratorOption */ ::=
    <sequence generator increment by option>   -> basic_sequence_generator_option_1
  | <sequence generator maxvalue option>       -> basic_sequence_generator_option_2
  | <sequence generator minvalue option>       -> basic_sequence_generator_option_3
  | <sequence generator cycle option>          -> basic_sequence_generator_option_4

<sequence generator increment by option> /* SequenceGeneratorIncrementByOption */ ::=
    INCREMENT BY
    <sequence generator increment>   -> sequence_generator_increment_by_option

<sequence generator increment> /* Expr */ ::=
    <signed numeric literal>

<sequence generator maxvalue option> /* SequenceGeneratorMaxvalueOption */ ::=
    MAXVALUE
    <sequence generator max value>   -> sequence_generator_maxvalue_option_1
  | NO MAXVALUE                      -> sequence_generator_maxvalue_option_2

<sequence generator minvalue option> /* SequenceGeneratorMinvalueOption */ ::=
    MINVALUE
    <sequence generator min value>   -> sequence_generator_minvalue_option_1
  | NO MINVALUE                      -> sequence_generator_minvalue_option_2

<sequence generator cycle option> /* bool */ ::=
    CYCLE      -> yes
  | NO CYCLE   -> no

<sequence generator max value> /* Expr */ ::=
    <signed numeric literal>

<sequence generator min value> /* Expr */ ::=
    <signed numeric literal>

<next value expression> /* Expr */ ::=
    NEXT VALUE FOR <sequence generator name>   -> next_value_expression

<drop sequence generator statement> /* Stmt */ ::=
    DROP SEQUENCE
    <sequence generator name>   -> drop_sequence_generator_statement

<alter sequence generator statement> /* Stmt */ ::=
    ALTER SEQUENCE
    <sequence generator name>
    <alter sequence generator options>   -> alter_sequence_generator_statement

<alter sequence generator options> /* []SequenceGeneratorOption */ ::=
    <alter sequence generator option>   -> sequence_generator_options_1
  | <alter sequence generator options>
    <alter sequence generator option>   -> sequence_generator_options_2

<alter sequence generator option> /* SequenceGeneratorOption */ ::=
    <alter sequence generator restart option>   -> alter_sequence_generator_option_1
  | <basic sequence generator option>

<alter sequence generator restart option> /* SequenceGeneratorRestartOption */ ::=
    RESTART                              -> sequence_generator_restart_option_1
  | RESTART WITH
    <sequence generator restart value>   -> sequence_generator_restart_option_2

<sequence generator restart value> /* Expr */ ::=
    <signed numeric literal>

<preparable SQL session statement> /* Stmt */ ::=
    <SQL session statement>

<SQL session statement> /* Stmt */ ::=
    <set schema statement>
  | <set catalog statement>

<set catalog statement> /* Stmt */ ::=
    SET <catalog name characteristic>   -> set_catalog_stmt

<catalog name characteristic> /* Expr */ ::=
    CATALOG <value specification>   -> expr

<set schema statement> /* Stmt */ ::=
    SET <schema name characteristic>   -> set_schema_stmt

<schema name characteristic> /* Expr */ ::=
    SCHEMA <value specification>   -> expr

<value specification> /* Expr */ ::=
    <literal>
  | <general value specification>

<catalog name> /* IdentifierChain */ ::=
    <identifier>
